Description: when the library asks the kernel for the key symbols, the result
             are truncated for unicode symbols if the keyboard is not in
             K_UNICODE mode. So, a temporary switch is needed, as well as
             applying the right bitmask in order to retrieve the full unicode
             symbol.
Author: Jérémy Bobbio <lunar@debian.org>
Bug-Debian: http://bugs.debian.org/401296

--- a/inputdrivers/keyboard/keyboard.c
+++ b/inputdrivers/keyboard/keyboard.c
@@ -87,6 +87,10 @@ keyboard_get_symbol( int                
      unsigned char index = KVAL(value);
      int           base  = (level == DIKSI_BASE);
 
+     /* Handle unicode characters directly */
+     if (type >= 0x0f) {
+          return DFB_KEY( UNICODE, value ^ 0xf000 );
+     }
      switch (type) {
           case KT_FN:
                if (index < 20)
@@ -454,10 +458,17 @@ driver_get_keymap_entry( CoreInputDevice
                          void                      *driver_data,
                          DFBInputDeviceKeymapEntry *entry )
 {
+     KeyboardData               *data = (KeyboardData*) driver_data;
      int                         code = entry->code;
      unsigned short              value;
      DFBInputDeviceKeyIdentifier identifier;
 
+     /* switch to unicode mode to get the full keymap */
+     if (ioctl( data->vt_fd, KDSKBMODE, K_UNICODE ) < 0) {
+          D_PERROR( "DirectFB/Keyboard: K_UNICODE failed!\n" );
+          return DFB_INIT;
+     }
+
      /* fetch the base level */
      value = keyboard_read_value( driver_data, K_NORMTAB, code );
 
@@ -501,6 +512,12 @@ driver_get_keymap_entry( CoreInputDevice
      entry->symbols[DIKSI_ALT_SHIFT] = keyboard_get_symbol( code, value,
                                                             DIKSI_ALT_SHIFT );
 
+     /* switch back to medium raw mode */
+     if (ioctl( data->vt_fd, KDSKBMODE, K_MEDIUMRAW ) < 0) {
+          D_PERROR( "DirectFB/Keyboard: K_MEDIUMRAW failed!\n" );
+          return DFB_INIT;
+     }
+
      return DFB_OK;
 }
 
--- a/inputdrivers/linux_input/linux_input.c
+++ b/inputdrivers/linux_input/linux_input.c
@@ -388,6 +388,10 @@ keyboard_get_symbol( int                
      unsigned char index = KVAL(value);
      int           base  = (level == DIKSI_BASE);
 
+     /* Handle unicode characters directly */
+     if (type >= 0x0f) {
+          return DFB_KEY( UNICODE, value ^ 0xf000 );
+     }
      switch (type) {
           case KT_FN:
                if (index < 20)
@@ -1327,10 +1331,23 @@ driver_get_keymap_entry( CoreInputDevice
      int                         code = entry->code;
      unsigned short              value;
      DFBInputDeviceKeyIdentifier identifier;
+     int                         orig_mode;
 
      if (!data->vt)
           return DFB_UNSUPPORTED;
 
+     /* save keyboard mode in order to restore it later */
+     if (ioctl( data->vt->fd, KDGKBMODE, &orig_mode ) < 0) {
+          D_PERROR( "DirectFB/Keyboard: KDGKBMODE failed!\n" );
+          return DFB_INIT;
+     }
+
+     /* switch to unicode mode to get the full keymap */
+     if (ioctl( data->vt->fd, KDSKBMODE, K_UNICODE ) < 0) {
+          D_PERROR( "DirectFB/Keyboard: K_UNICODE failed!\n" );
+          return DFB_INIT;
+     }
+
      /* fetch the base level */
      value = keyboard_read_value( driver_data, K_NORMTAB, code );
 
@@ -1374,6 +1391,12 @@ driver_get_keymap_entry( CoreInputDevice
      entry->symbols[DIKSI_ALT_SHIFT] = keyboard_get_symbol( code, value,
                                                             DIKSI_ALT_SHIFT );
 
+     /* switch back to original mode */
+     if (ioctl( data->vt->fd, KDSKBMODE, orig_mode ) < 0) {
+          D_PERROR( "DirectFB/Keyboard: KDSKBMODE failed!\n" );
+          return DFB_INIT;
+     }
+
      return DFB_OK;
 #else
      return DFB_UNSUPPORTED;
